package playground.anuj.charDham.analysis;

import org.matsim.api.core.v01.Id;
import org.matsim.core.api.experimental.events.EventsManager;
import org.matsim.core.events.EventsUtils;
import org.matsim.core.events.MatsimEventsReader;
import org.matsim.core.utils.io.IOUtils;
import org.matsim.facilities.ActivityFacility;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

/**
 * A standalone class to analyze the output events from multiple MATSim simulation runs
 * generated by RunCharDhamMultipleSimulation. It aggregates key metrics into a single CSV summary.
 */
public class CharDhamOutputAnalyzer {

    private static final String BASE_OUTPUT_DIRECTORY = "output/charDham_runs/"; // Must match RunCharDhamMultipleSimulation
    private static final String PARAMETER_RUNS_CSV = "input/parameter_runs.csv"; // Must match RunCharDhamMultipleSimulation
    private static final String ANALYSIS_SUMMARY_CSV = BASE_OUTPUT_DIRECTORY + "analysis_summary.csv";
    private static final String FACILITY_REST_ANALYSIS_CSV = BASE_OUTPUT_DIRECTORY + "facility_rest_analysis.csv";
    private static final String DHAM_ACTIVITY_ANALYSIS_CSV = BASE_OUTPUT_DIRECTORY + "dham_activity_analysis.csv";

    // Modes are needed for consistent header generation in the summary CSV
    static final String CAR_MODE = "car";
    static final String MOTORBIKE_MODE = "motorbike";
    static final String TRAVELLER_MODE = "traveller";
    static final Collection<String> modes = Arrays.asList(CAR_MODE, MOTORBIKE_MODE, TRAVELLER_MODE);

    private static final Set<String> DHAM_ACTIVITY_TYPES = new HashSet<>(Arrays.asList(
            "Kedarnath", "Gangotri", "Yamunotri", "Badrinath"
    ));

    /**
     * Helper class to hold parameters for a single simulation run.
     * Only 'runId' and 'lastIteration' are strictly needed for analysis,
     * but keeping the full structure for consistency and potential future use.
     */
    private static class RunParameters {
        String runId;
        int lastIteration;
        // Other parameters from CSV are not directly used by the analyzer, but could be added to summary if desired.
        // double flowCapacityFactor;

        RunParameters(String[] parts, String[] headers) {
            Map<String, String> dataMap = new HashMap<>();
            for (int i = 0; i < headers.length; i++) {
                if (i < parts.length) {
                    dataMap.put(headers[i].trim(), parts[i].trim());
                }
            }
            this.runId = dataMap.getOrDefault("run_id", "default_run");
            this.lastIteration = Integer.parseInt(dataMap.getOrDefault("last_iteration", "20"));
        }
    }

    public static void main(String[] args) {
        List<RunParameters> runs = readRunParameters();

        if (runs.isEmpty()) {
            System.err.println("No simulation parameters found in " + PARAMETER_RUNS_CSV + ". Cannot perform analysis. Exiting.");
            return;
        }

        System.out.println("Starting analysis of MATSim simulation outputs...");

        try {
            // Ensure the base output directory exists for the summary file
            Files.createDirectories(Paths.get(BASE_OUTPUT_DIRECTORY));
            writeAnalysisSummaryHeader();
            writeFacilityRestAnalysisHeader();
            writeDhamActivityAnalysisHeader();
        } catch (IOException e) {
            System.err.println("Error preparing analysis summary file: " + e.getMessage());
            e.printStackTrace();
            return;
        }

        for (int i = 0; i < runs.size(); i++) {
            RunParameters params = runs.get(i);
            String runOutputDir = BASE_OUTPUT_DIRECTORY + params.runId + "/";
            String eventsFilePath = runOutputDir + "output_events.xml.gz";

            System.out.println("\n--- Analyzing Run: " + params.runId + " (Run " + (i + 1) + " of " + runs.size() + ") ---");
            System.out.println("Looking for events file: " + eventsFilePath);

            Path eventsPath = Paths.get(eventsFilePath);
            if (!Files.exists(eventsPath)) {
                System.err.println("!!! Events file not found for run " + params.runId + " at " + eventsFilePath + ". Skipping this run.");
                continue;
            }

            try {
                SimulationAnalysisResult result = processSingleRunEvents(params.runId, params.lastIteration, eventsFilePath);
                writeAnalysisResultToSummary(result);
                writeFacilityRestAnalysisData(result);
                writeDhamActivityAnalysisData(result);
                System.out.println("--- Analysis for " + params.runId + " COMPLETED ---");
            } catch (Exception e) {
                System.err.println("!!! Error analyzing events for run " + params.runId + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
        System.out.println("\nAll analyses finished. Summary available at: " + ANALYSIS_SUMMARY_CSV);
    }
    /**
     * Writes the header for the per-facility rest activity analysis CSV file.
     *
     * @throws IOException If an I/O error occurs.
     */
    private static void writeFacilityRestAnalysisHeader() throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(CharDhamOutputAnalyzer.FACILITY_REST_ANALYSIS_CSV, false))) { // false to overwrite
            List<String> headers = new ArrayList<>();
            headers.add("run_id");
            headers.add("iteration");
            headers.add("facility_link_id");
            headers.add("total_rest_uses");
            headers.add("total_rest_duration_s");
            headers.add("average_rest_duration_s");
            writer.println(String.join(",", headers));
        }
    }

    /**
     * ppends per-facility rest activity data to the facility analysis CSV file.
     *
     * @param result The SimulationAnalysisResult object containing per-facility data.
     * @throws IOException If an I/O error occurs.
     */
    private static void writeFacilityRestAnalysisData(SimulationAnalysisResult result) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(CharDhamOutputAnalyzer.FACILITY_REST_ANALYSIS_CSV, true))) { // true to append
            for (Map.Entry<Id<ActivityFacility>, Integer> entry : result.totalRestActivityUsesPerFacility.entrySet()) {
                Id<ActivityFacility> activityFacilityId = entry.getKey();
                int totalUses = entry.getValue();
                double totalDuration = result.totalRestDurationPerActivityFacility.getOrDefault(activityFacilityId, 0.0);
                double averageDuration = result.avgRestDurationPerActivityFacility.getOrDefault(activityFacilityId, 0.0);

                List<String> row = new ArrayList<>();
                row.add(result.runId);
                row.add(String.valueOf(result.iteration));
                row.add(String.valueOf(activityFacilityId));
                row.add(String.valueOf(totalUses));
                row.add(String.valueOf(totalDuration));
                row.add(String.valueOf(averageDuration));
                writer.println(String.join(",", row));
            }
        }
    }
    /**
     * Reads simulation parameters from a CSV file.
     *
     * @return A list of RunParameters objects, one for each row.
     */
    private static List<RunParameters> readRunParameters() {
        List<RunParameters> runs = new ArrayList<>();
        try (BufferedReader br = IOUtils.getBufferedReader(CharDhamOutputAnalyzer.PARAMETER_RUNS_CSV)) {
            String headerLine = br.readLine();
            if (headerLine == null) {
                System.err.println("CSV file is empty: " + CharDhamOutputAnalyzer.PARAMETER_RUNS_CSV);
                return runs;
            }
            String[] headers = headerLine.split(",");

            String line;
            while ((line = br.readLine()) != null) {
                if (line.trim().isEmpty()) continue; // Skip empty lines
                String[] parts = line.split(",");
                if (parts.length != headers.length) {
                    System.err.println("Warning: Skipping malformed line (column count mismatch) in " + CharDhamOutputAnalyzer.PARAMETER_RUNS_CSV + ": " + line + ". Expected " + headers.length + " columns, found " + parts.length + ".");
                    continue;
                }
                try {
                    runs.add(new RunParameters(parts, headers));
                } catch (NumberFormatException e) {
                    System.err.println("Warning: Skipping line due to number format error in " + CharDhamOutputAnalyzer.PARAMETER_RUNS_CSV + ": " + line + " - " + e.getMessage());
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading parameter runs CSV file: " + CharDhamOutputAnalyzer.PARAMETER_RUNS_CSV);
            e.printStackTrace();
        }
        return runs;
    }

    /**
     * Processes the events file for a single simulation run and returns the aggregated results.
     *
     * @param runId The ID of the simulation run.
     * @param iteration The last iteration of the simulation run.
     * @param eventsFilePath The path to the output_events.xml.gz file.
     * @return A SimulationAnalysisResult object.
     */
    private static SimulationAnalysisResult processSingleRunEvents(String runId, int iteration, String eventsFilePath) {
        EventsManager eventsManager = EventsUtils.createEventsManager();
        CharDhamAnalysisEventHandler analysisHandler = new CharDhamAnalysisEventHandler(runId, iteration);
        eventsManager.addHandler(analysisHandler);

        MatsimEventsReader eventsReader = new MatsimEventsReader(eventsManager);
        eventsReader.readFile(eventsFilePath); // This will throw IOException if file is not found/readable

        return analysisHandler.getAnalysisResults();
    }

    /**
     * Writes the header for the analysis summary CSV file.
     *
     * @throws IOException If an I/O error occurs.
     */
    private static void writeAnalysisSummaryHeader() throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(CharDhamOutputAnalyzer.ANALYSIS_SUMMARY_CSV, false))) { // false to overwrite
            List<String> headers = new ArrayList<>();
            headers.add("run_id");
            headers.add("iteration");
            headers.add("total_agents_simulated");
            headers.add("total_travel_time_s");
            headers.add("average_travel_time_s");
            headers.add("min_travel_time_s");
            headers.add("max_travel_time_s");
            headers.add("total_legs");
            headers.add("average_leg_travel_time_s");

            // Add headers for rest activity metrics (example for a few facilities, or dynamically if needed)
            headers.add("num_rest_facilities_visited");
            headers.add("total_rest_duration_all_facilities_s");
            headers.add("avg_rest_duration_all_facilities_s"); // Average of averages or total/total agents

            // Headers for Dham activity metrics
            for (String dhamType : DHAM_ACTIVITY_TYPES) {
                headers.add(dhamType + "_uses");
                headers.add(dhamType + "_total_duration_s");
                headers.add(dhamType + "_avg_duration_s");
            }

            // Header for nighttime travel
            headers.add("total_night_travel_time_s");
            headers.add("num_agents_night_travel");

            // Add headers for mode-specific metrics
            for (String mode : modes) {
                headers.add("legs_" + mode);
                headers.add("travel_time_" + mode + "_s");
                headers.add("avg_travel_time_" + mode + "_s");
            }

            writer.println(String.join(",", headers));
        }
    }

    /**
     * Appends a row of analysis results to the summary CSV file.
     *
     * @param result The SimulationAnalysisResult object.
     * @throws IOException If an I/O error occurs.
     */
    private static void writeAnalysisResultToSummary(SimulationAnalysisResult result) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(CharDhamOutputAnalyzer.ANALYSIS_SUMMARY_CSV, true))) { // true to append
            List<String> row = new ArrayList<>();
            row.add(result.runId);
            row.add(String.valueOf(result.iteration));
            row.add(String.valueOf(result.totalAgentsSimulated));
            row.add(String.valueOf(result.totalTravelTime_s));
            row.add(String.valueOf(result.averageTravelTime_s));
            row.add(String.valueOf(result.minTravelTime_s));
            row.add(String.valueOf(result.maxTravelTime_s));
            row.add(String.valueOf(result.totalLegs));
            row.add(String.valueOf(result.averageLegTravelTime_s));

            // Aggregate rest activity metrics for summary
            int totalRestActivityUsesAllFacilities = result.totalRestActivityUsesPerFacility.values().stream().mapToInt(Integer::intValue).sum();
            double totalRestDurationAllFacilities = result.totalRestDurationPerActivityFacility.values().stream().mapToDouble(Double::doubleValue).sum();
            double avgRestDurationAllFacilities = totalRestActivityUsesAllFacilities > 0 ?
                    result.avgRestDurationPerActivityFacility.values().stream().mapToDouble(Double::doubleValue).average().orElse(0.0) : 0.0;

            row.add(String.valueOf(totalRestActivityUsesAllFacilities));
            row.add(String.valueOf(totalRestDurationAllFacilities));
            row.add(String.valueOf(avgRestDurationAllFacilities));

            for (String dhamType : DHAM_ACTIVITY_TYPES) {
                row.add(String.valueOf(result.totalDhamActivityUses.getOrDefault(dhamType, 0)));
                row.add(String.valueOf(result.totalDhamDuration.getOrDefault(dhamType, 0.0)));
                row.add(String.valueOf(result.avgDhamDuration.getOrDefault(dhamType, 0.0)));
            }
            // dd nighttime travel metric
            row.add(String.valueOf(result.totalNightTravelTime_s));
            row.add(String.valueOf(result.numAgentsNightTravel));

            // Add mode-specific metrics
            for (String mode : modes) {
                row.add(String.valueOf(result.totalLegsPerMode.getOrDefault(mode, 0)));
                row.add(String.valueOf(result.totalTravelTimePerMode.getOrDefault(mode, 0.0)));
                row.add(String.valueOf(result.avgTravelTimePerMode.getOrDefault(mode, 0.0)));
            }

            writer.println(String.join(",", row));
        }
    }
    /**
     * NEW: Writes the header for the per-Dham activity analysis CSV file.
     *
     * @throws IOException If an I/O error occurs.
     */
    private static void writeDhamActivityAnalysisHeader() throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(CharDhamOutputAnalyzer.DHAM_ACTIVITY_ANALYSIS_CSV, false))) { // false to overwrite
            List<String> headers = new ArrayList<>();
            headers.add("run_id");
            headers.add("iteration");
            headers.add("dham_activity_type");
            headers.add("total_dham_uses");
            headers.add("total_dham_duration_s");
            headers.add("average_dham_duration_s");
            writer.println(String.join(",", headers));
        }
    }

    /**
     * NEW: Appends per-Dham activity data to the Dham activity analysis CSV file.
     *
     * @param result The SimulationAnalysisResult object containing per-Dham data.
     * @throws IOException If an I/O error occurs.
     */
    private static void writeDhamActivityAnalysisData(SimulationAnalysisResult result) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(CharDhamOutputAnalyzer.DHAM_ACTIVITY_ANALYSIS_CSV, true))) { // true to append
            for (String dhamType : DHAM_ACTIVITY_TYPES) { // Iterate through predefined Dham types
                int totalUses = result.totalDhamActivityUses.getOrDefault(dhamType, 0);
                double totalDuration = result.totalDhamDuration.getOrDefault(dhamType, 0.0);
                double averageDuration = result.avgDhamDuration.getOrDefault(dhamType, 0.0);

                List<String> row = new ArrayList<>();
                row.add(result.runId);
                row.add(String.valueOf(result.iteration));
                row.add(dhamType);
                row.add(String.valueOf(totalUses));
                row.add(String.valueOf(totalDuration));
                row.add(String.valueOf(averageDuration));
                writer.println(String.join(",", row));
            }
        }
    }
}