package playground.anuj.charDham.analysis;

import org.matsim.api.core.v01.Id;
import org.matsim.core.api.experimental.events.EventsManager;
import org.matsim.core.events.EventsUtils;
import org.matsim.core.events.MatsimEventsReader;
import org.matsim.core.utils.io.IOUtils;
import org.matsim.facilities.ActivityFacility;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

import static playground.anuj.charDham.population.CharDhamInitialPlans.*;

/**
 * A standalone class to analyze the output events from multiple MATSim simulation runs
 * generated by RunCharDhamMultipleSimulation. It aggregates key metrics into a single CSV summary.
 */
public class CharDhamOutputAnalyzer {

    private static final String BASE_OUTPUT_DIRECTORY = "output/charDham_runs/"; // Must match RunCharDhamMultipleSimulation
    private static final String PARAMETER_RUNS_CSV = "input/parameter_runs.csv"; // Must match RunCharDhamMultipleSimulation
    private static final String ANALYSIS_SUMMARY_BASE_NAME = "analysis_summary";
    private static final String FACILITY_REST_ANALYSIS_BASE_NAME = "facility_rest_analysis";
    private static final String DHAM_ACTIVITY_ANALYSIS_BASE_NAME = "dham_activity_analysis";

    // Modes are needed for consistent header generation in the summary CSV
    static final Collection<String> modes = Arrays.asList(CAR_MODE, TAXI_MODE, MOTORBIKE_MODE, BUS_MODE, WALK_MODE);

    static final Set<String> DHAM_ACTIVITY_TYPES = new HashSet<>(Arrays.asList(
            "Kedarnath", "Gangotri", "Yamunotri", "Badrinath", "Hemkund_Sahib"
    ));

    private static class RunParameters {
        String runId;
        int lastIteration;

        RunParameters(String[] parts, String[] headers) {
            Map<String, String> dataMap = new HashMap<>();
            for (int i = 0; i < headers.length; i++) {
                if (i < parts.length) {
                    dataMap.put(headers[i].trim(), parts[i].trim());
                }
            }
            this.runId = dataMap.getOrDefault("run_id", "default_run");
            this.lastIteration = Integer.parseInt(dataMap.getOrDefault("last_iteration", "20"));
        }
    }

    public static void main(String[] args) {
        List<RunParameters> runs = readRunParameters();

        if (runs.isEmpty()) {
            System.err.println("No simulation parameters found in " + PARAMETER_RUNS_CSV + ". Cannot perform analysis. Exiting.");
            return;
        }

        System.out.println("Starting analysis of MATSim simulation outputs...");

        try {
            // Ensure the base output directory exists for the summary files
            Files.createDirectories(Paths.get(BASE_OUTPUT_DIRECTORY));
            // Headers will be written for each day (dayX and all_days) dynamically
        } catch (IOException e) {
            System.err.println("Error preparing analysis summary file: " + e.getMessage());
            e.printStackTrace();
            return;
        }

        // Keep track of which days (dayX and all_days) have had their headers written
        Set<String> writtenHeaders = new HashSet<>();

        for (int i = 0; i < runs.size(); i++) {
            RunParameters params = runs.get(i);
            String runOutputDir = BASE_OUTPUT_DIRECTORY + params.runId + "/";
            String eventsFilePath = runOutputDir + "output_events.xml.gz";

            System.out.println("\n--- Analyzing Run: " + params.runId + " (Run " + (i + 1) + " of " + runs.size() + ") ---");
            System.out.println("Looking for events file: " + eventsFilePath);

            Path eventsPath = Paths.get(eventsFilePath);
            if (!Files.exists(eventsPath)) {
                System.err.println("!!! Events file not found for run " + params.runId + " at " + eventsFilePath + ". Skipping this run.");
                continue;
            }

            try {
                // Process events and get results for all days (day-wise + all_days)
                Map<String, SimulationAnalysisResult> resultsByPeriod = processSingleRunEvents(params.runId, params.lastIteration, eventsFilePath);

                for (Map.Entry<String, SimulationAnalysisResult> entry : resultsByPeriod.entrySet()) {
                    String day = entry.getKey();
                    SimulationAnalysisResult result = entry.getValue();

                    // Write headers if not already written for this day
                    if (!writtenHeaders.contains(day)) {
                        writeAnalysisSummaryHeader(day);
                        writeFacilityRestAnalysisHeader(day);
                        writeDhamActivityAnalysisHeader(day);
                        writtenHeaders.add(day);
                    }

                    // Append data for this day
                    writeAnalysisResultToSummary(result);
                    writeFacilityRestAnalysisData(result);
                    writeDhamActivityAnalysisData(result);
                }
                System.out.println("--- Analysis for " + params.runId + " COMPLETED ---");
            } catch (Exception e) {
                System.err.println("!!! Error analyzing events for run " + params.runId + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
        System.out.println("\nAll analyses finished. Summaries available in: " + BASE_OUTPUT_DIRECTORY);
    }

    /**
     * Reads simulation parameters from a CSV file.
     *
     * @return A list of RunParameters objects, one for each row.
     */
    private static List<RunParameters> readRunParameters() {
        List<RunParameters> runs = new ArrayList<>();
        try (BufferedReader br = IOUtils.getBufferedReader(PARAMETER_RUNS_CSV)) {
            String headerLine = br.readLine();
            if (headerLine == null) {
                System.err.println("CSV file is empty: " + PARAMETER_RUNS_CSV);
                return runs;
            }
            String[] headers = headerLine.split(",");

            String line;
            while ((line = br.readLine()) != null) {
                if (line.trim().isEmpty()) continue; // Skip empty lines
                String[] parts = line.split(",");
                if (parts.length != headers.length) {
                    System.err.println("Warning: Skipping malformed line (column count mismatch) in " + PARAMETER_RUNS_CSV + ": " + line + ". Expected " + headers.length + " columns, found " + parts.length + ".");
                    continue;
                }
                try {
                    runs.add(new RunParameters(parts, headers));
                } catch (NumberFormatException e) {
                    System.err.println("Warning: Skipping line due to number format error in " + PARAMETER_RUNS_CSV + ": " + line + " - " + e.getMessage());
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading parameter runs CSV file: " + PARAMETER_RUNS_CSV);
            e.printStackTrace();
        }
        return runs;
    }

    /**
     * Processes the events file for a single simulation run and returns the aggregated results.
     *
     * @param runId          The ID of the simulation run.
     * @param iteration      The last iteration of the simulation run.
     * @param eventsFilePath The path to the output_events.xml.gz file.
     * @return A Map where keys are "dayX" or "all_days", and values are SimulationAnalysisResult objects.
     */
    private static Map<String, SimulationAnalysisResult> processSingleRunEvents(String runId, int iteration, String eventsFilePath) {
        EventsManager eventsManager = EventsUtils.createEventsManager();
        CharDhamAnalysisEventHandler analysisHandler = new CharDhamAnalysisEventHandler(runId, iteration);
        eventsManager.addHandler(analysisHandler);

        MatsimEventsReader eventsReader = new MatsimEventsReader(eventsManager);
        eventsReader.readFile(eventsFilePath); // This will throw IOException if file is not found/readable

        return analysisHandler.getAnalysisResults();
    }

    /**
     * Generates the full file path for a given base name and day.
     *
     * @param baseName The base name of the CSV file (e.g., "analysis_summary").
     * @param day      The day (e.g., "day1", "all_days").
     * @return The full file path.
     */
    private static String getFilePath(String baseName, String day) {
        return BASE_OUTPUT_DIRECTORY + baseName + "_" + day + ".csv";
    }

    /**
     * Writes the header for the main analysis summary CSV file for a specific day.
     *
     * @param day The day (e.g., "day1", "all_days").
     * @throws IOException If an I/O error occurs.
     */
    private static void writeAnalysisSummaryHeader(String day) throws IOException {
        String filePath = getFilePath(ANALYSIS_SUMMARY_BASE_NAME, day);
        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, false))) { // false to overwrite
            List<String> headers = new ArrayList<>();
            headers.add("run_id");
            headers.add("iteration");
            headers.add("total_agents_simulated");
            headers.add("total_travel_time_s");
            headers.add("average_travel_time_s");
            headers.add("min_travel_time_s");
            headers.add("max_travel_time_s");
            headers.add("total_legs");
            headers.add("average_leg_travel_time_s");

            // Changed header names to reflect "unique persons" and removed duration headers
            headers.add("unique_rest_activity_persons_all_facilities");
            headers.add("unique_dham_activity_persons_all");

            headers.add("total_night_travel_time_s");
            headers.add("num_agents_night_travel");

            for (String mode : modes) {
                headers.add("legs_" + mode);
                headers.add("travel_time_" + mode + "_s");
                headers.add("avg_travel_time_" + mode + "_s");
            }

            for (String mode : modes) {
                headers.add("percentage_legs_" + mode);
            }

            writer.println(String.join(",", headers));
        }
    }

    /**
     * Appends a row of overall analysis results to the main summary CSV file.
     *
     * @param result The SimulationAnalysisResult object.
     * @throws IOException If an I/O error occurs.
     */
    private static void writeAnalysisResultToSummary(SimulationAnalysisResult result) throws IOException {
        String filePath = getFilePath(ANALYSIS_SUMMARY_BASE_NAME, result.day);
        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, true))) { // true to append
            List<String> row = new ArrayList<>();
            row.add(result.runId);
            row.add(String.valueOf(result.iteration));
            row.add(String.valueOf(result.totalAgentsSimulated));
            row.add(String.valueOf(result.totalTravelTime_s));
            row.add(String.valueOf(result.averageTravelTime_s));
            row.add(String.valueOf(result.minTravelTime_s));
            row.add(String.valueOf(result.maxTravelTime_s));
            row.add(String.valueOf(result.totalLegs));
            row.add(String.valueOf(result.averageLegTravelTime_s));

            // Use the derived counts from SimulationAnalysisResult and removed duration fields
            int uniqueRestActivityPersonsAllFacilities = result.totalRestActivityUsesPerFacilityCount.values().stream().mapToInt(Integer::intValue).sum();
            row.add(String.valueOf(uniqueRestActivityPersonsAllFacilities));

            int uniqueDhamActivityPersonsAll = result.totalDhamActivityUsesCount.values().stream().mapToInt(Integer::intValue).sum();
            row.add(String.valueOf(uniqueDhamActivityPersonsAll));

            row.add(String.valueOf(result.totalNightTravelTime_s));
            row.add(String.valueOf(result.numAgentsNightTravel));

            for (String mode : modes) {
                row.add(String.valueOf(result.totalLegsPerMode.getOrDefault(mode, 0)));
                row.add(String.valueOf(result.totalTravelTimePerMode.getOrDefault(mode, 0.0)));
                row.add(String.valueOf(result.avgTravelTimePerMode.getOrDefault(mode, 0.0)));
            }

            for (String mode : modes) {
                row.add(String.valueOf(result.percentageLegsPerMode.getOrDefault(mode, 0.0)));
            }

            writer.println(String.join(",", row));
        }
    }

    /**
     * Writes the header for the per-facility rest activity analysis CSV file for a specific day.
     *
     * @param day The day (e.g., "day1", "all_days").
     * @throws IOException If an I/O error occurs.
     */
    private static void writeFacilityRestAnalysisHeader(String day) throws IOException {
        String filePath = getFilePath(FACILITY_REST_ANALYSIS_BASE_NAME, day);
        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, false))) { // false to overwrite
            List<String> headers = new ArrayList<>();
            headers.add("run_id");
            headers.add("iteration");
            headers.add("facility_id");
            headers.add("unique_rest_persons"); // Changed header, removed duration headers
            writer.println(String.join(",", headers));
        }
    }

    /**
     * Appends per-facility rest activity data to the facility analysis CSV file.
     *
     * @param result The SimulationAnalysisResult object containing per-facility data.
     * @throws IOException If an I/O error occurs.
     */
    private static void writeFacilityRestAnalysisData(SimulationAnalysisResult result) throws IOException {
        String filePath = getFilePath(FACILITY_REST_ANALYSIS_BASE_NAME, result.day);
        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, true))) { // true to append
            // Iterate through the derived counts
            for (Map.Entry<Id<ActivityFacility>, Integer> entry : result.totalRestActivityUsesPerFacilityCount.entrySet()) {
                Id<ActivityFacility> activityFacilityId = entry.getKey();
                int uniquePersons = entry.getValue(); // Use unique persons count

                List<String> row = new ArrayList<>();
                row.add(result.runId);
                row.add(String.valueOf(result.iteration));
                row.add(String.valueOf(activityFacilityId));
                row.add(String.valueOf(uniquePersons));
                writer.println(String.join(",", row));
            }
        }
    }

    /**
     * Writes the header for the per-Dham activity analysis CSV file for a specific day.
     *
     * @param day The day (e.g., "day1", "all_days").
     * @throws IOException If an I/O error occurs.
     */
    private static void writeDhamActivityAnalysisHeader(String day) throws IOException {
        String filePath = getFilePath(DHAM_ACTIVITY_ANALYSIS_BASE_NAME, day);
        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, false))) { // false to overwrite
            List<String> headers = new ArrayList<>();
            headers.add("run_id");
            headers.add("iteration");
            headers.add("dham_activity_type");
            headers.add("unique_dham_persons");
            writer.println(String.join(",", headers));
        }
    }

    /**
     * Appends per-Dham activity data to the Dham activity analysis CSV file.
     *
     * @param result The SimulationAnalysisResult object containing per-Dham data.
     * @throws IOException If an I/O error occurs.
     */
    private static void writeDhamActivityAnalysisData(SimulationAnalysisResult result) throws IOException {
        String filePath = getFilePath(DHAM_ACTIVITY_ANALYSIS_BASE_NAME, result.day);
        try (PrintWriter writer = new PrintWriter(new FileWriter(filePath, true))) { // true to append
            for (String dhamType : DHAM_ACTIVITY_TYPES) { // Iterate through predefined Dham types
                // Use the derived counts from SimulationAnalysisResult
                int uniquePersons = result.totalDhamActivityUsesCount.getOrDefault(dhamType, 0);

                List<String> row = new ArrayList<>();
                row.add(result.runId);
                row.add(String.valueOf(result.iteration));
                row.add(dhamType);
                row.add(String.valueOf(uniquePersons));
                writer.println(String.join(",", row));
            }
        }
    }
}